<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <title>Extractor Datos Llantas PDF + OCR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f8f9fa; }
        h1 { text-align: center; }
        .container { text-align: center; padding: 30px; }
        .upload-area {
            border: 2px dashed #007bff;
            padding: 40px; margin: 20px auto; 
            max-width: 500px;
            cursor: pointer;
            border-radius: 10px;
            background: white;
        }
        .upload-area:hover {background: #e3f2fd;}
        input[type="file"] {display:none;}
        button {
            margin: 10px;
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .btn-primary { background: #28a745; color: white; }
        .btn-primary:hover { background: #218838; }
        .btn-secondary { background: #dc3545; color: white; }
        .btn-secondary:hover { background: #c82333; }
        .btn-disabled { background: #6c757d; cursor: not-allowed; }
        #status {
            margin: 25px auto;
            padding: 15px;
            max-width: 600px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 18px;
            display: none;
        }
        .status-ready { background: #d4edda; color: #155724; }
        .status-processing { background: #fff3cd; color: #856404; }
        .status-error { background: #f8d7da; color: #721c24; }
        .status-ocr { background: #d1ecf1; color: #0c5460; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            background: white;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th { background: #007bff; color: white; }
        /* Inputs inside the results table */
        table input {
            font-size: 14px;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }
        input.cell-qty { width: 80px; }
        tr.edited td { outline: 2px solid rgba(255,193,7,0.15); background: #fffdf6; }

        /* Thumbnail panel (floating) */
        .thumbnail-panel {
            position: fixed;
            right: 18px;
            top: 18px; /* moved higher to avoid overlapping action buttons */
            width: 140px;
            max-height: 70vh;
            overflow-y: auto;
            background: rgba(255,255,255,0.97);
            border: 1px solid #ddd;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            z-index: 1000;
            display: none; /* hidden by default; toggle with button */
        }
        .thumbnail-panel .thumb { display:flex; align-items:center; gap:8px; margin-bottom:8px; cursor:pointer; }
        .thumbnail-panel .thumb img { width: 110px; height: auto; border-radius:4px; display:block; }
        .thumbnail-panel .thumb .index { font-size:12px; color:#555; margin-left:4px; }

        /* Thumb toggle button (show/hide thumbnails) */
        #thumbToggle {
            position: fixed;
            right: 18px;
            top: 18px;
            z-index: 1350;
            padding: 10px 12px;
            border-radius: 8px;
            background: #fff;
            border: 1px solid #ddd;
            box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            cursor: pointer;
            display: none;
            font-weight: bold;
        }
        #thumbToggle.active { background: #007bff; color:#fff; border-color: #007bff; }

        /* Make result container relative so send button can be less intrusive */
        #result { position: relative; }
        #btnSendSheet {
            position: absolute;
            top: 10px;
            right: 12px;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 6px;
        }

        @media (max-width: 480px) {
            #btnSendSheet { top: 8px; right: 8px; padding: 8px 10px; font-size: 13px; }
        }

        /* Hover preview box */
        .thumb-preview {
            position: fixed;
            right: 170px;
            top: 18px; /* align preview near top so it doesn't hide buttons */
            width: 360px;
            max-height: 80vh;
            overflow: hidden;
            display: none;
            border-radius: 6px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            background: #fff;
            z-index: 1100;
        }
        .thumb-preview img { width: 100%; height: auto; display:block; }

        /* Tweak modal content max size */
        .modal .modal-content { max-width: 92%; max-height: 92%; }
        .modal .modal-content img { width: 100%; height: auto; }
        
        /* Floating viewer window styles */
        .floating-window { position: fixed; width: 780px; max-width: 92%; z-index: 1200; top: 10vh; left: 50%; transform: translateX(-50%); border-radius: 8px; overflow: hidden; background: #fff; }
        .floating-header { background: #007bff; color: #fff; padding: 8px 10px; font-weight: bold; display:flex; align-items:center; justify-content:space-between; cursor: move; }
        .floating-header button { margin-left:8px; }
        .modal.pinned { pointer-events: auto; } /* when pinned, ignore outside clicks for closing */
        @media (max-width: 600px) {
            .floating-window { width: 95%; left: 50%; transform: translateX(-50%); top: 6vh; }
        }
        
        .progress-container {
            display: none;
            max-width: 600px;
            margin: 20px auto;
            background: white;
            padding: 15px;
            border-radius: 10px;
        }
        .progress-bar-bg {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        .progress-text {
            text-align: center;
            font-size: 14px;
            color: #495057;
        }
        /* Modal para pedir el Nombre antes de enviar */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #fff;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 420px;
            border-radius: 8px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.2);
        }
        .modal-actions { text-align: right; margin-top: 12px; }
        .modal-content h3 { margin: 0 0 8px 0; font-size: 18px; }
        .modal-content p { margin: 0 0 12px 0; color: #555; font-size: 14px; }
        #sheetNameInput { width: 100%; padding: 10px 12px; font-size: 15px; border: 1px solid #ced4da; border-radius: 6px; box-sizing: border-box; }
        /* Mejor apariencia para botones dentro del modal */
        .modal .btn-primary { background: #007bff; padding: 10px 14px; border-radius: 6px; }
        .modal .btn-secondary { background: #6c757d; padding: 10px 14px; border-radius: 6px; }
        /* Bot√≥n junto a INICIAR ESCANEO */
        #btnClearCache {
            position: static;
            display: inline-block;
            box-shadow: none;
            padding: 12px 18px;
            border-radius: 5px;
            margin-left: 8px;
            vertical-align: middle;
        }
        @media (max-width: 480px) {
            #btnClearCache { padding: 10px 14px; font-size: 14px; margin-left: 6px; display: inline-block; }
        }
    </style>
</head>
<body>
    <h1>Escanea tus traspasos para ser m√°s √°gil el proceso</h1>
    <div class="container">
        <div class="upload-area" onclick="document.getElementById('pdfInput').click()">
            <p>üìÅ Haz clic o arrastra aqu√≠ para seleccionar tu PDF</p>
            <input type="file" id="pdfInput" accept=".pdf" />
        </div>
        <button id="btnStart" class="btn-primary btn-disabled" onclick="startScan()" disabled>üöÄ INICIAR ESCANEO</button>
        <button id="btnClearCache" class="btn-secondary" onclick="confirmClearCache()" title="Limpiar cach√© y recargar" aria-label="Limpiar cach√©">üßπ LIMPIAR CACHE</button>
        <button id="btnClear" class="btn-secondary" onclick="clearAll()" style="display:none;">üóëÔ∏è LIMPIAR TODO</button>
        <div style="margin-top:10px; font-size:14px; color:#333;">
            <label style="cursor:pointer;"><input id="enableAdvancedPreproc" type="checkbox" checked style="margin-right:6px;"> Preprocesado avanzado (OpenCV)</label>
            <span id="opencvStatus" style="margin-left:12px; color:#666;">Cargando OpenCV...</span>
        </div>
    </div>
    <div id="status" class="status-ready">Esperando archivo PDF...</div>

    <div id="progressContainer" class="progress-container">
        <div class="progress-bar-bg">
            <div id="progressBar" class="progress-bar-fill"></div>
        </div>
        <div class="progress-text">
            <span id="progressText">0%</span> - <span id="pageCounter">P√°gina 0/0</span>
        </div>
    </div>

    <div id="result" style="display:none; max-width: 900px; margin: 20px auto; background:white; padding:10px; border-radius:10px;">
        <div style="text-align:center;">
            <button id="btnSendSheet" class="btn-primary" onclick="openNameModal()">üì§ ENVIAR A HOJA</button>
        </div>
        <div id="tableContainer"></div>
        <div id="pageSummaries" style="margin-top:12px; font-size:14px;"></div>
        <!-- Modal para pedir Nombre antes de enviar -->
        <div id="nameModal" class="modal">
            <div class="modal-content">
                <h3>Ingresa el nombre para la hoja</h3>
                <p>Este nombre se asignar√° a la columna <strong>traspasos/Nombre</strong> en la hoja.</p>
                <input id="sheetNameInput" type="text" placeholder="Nombre (ej. Sucursal A)" style="width:100%; padding:8px; font-size:16px;" />
                <div class="modal-actions">
                    <button class="btn-secondary" onclick="closeNameModal()">Cancelar</button>
                    <button class="btn-primary" onclick="confirmSendToSheetDB()">Enviar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Thumbnail floating panel and preview -->
    <div id="thumbnailPanel" class="thumbnail-panel" style="display:none;" aria-hidden="true"></div>
    <div id="thumbPreview" class="thumb-preview" style="display:none;" aria-hidden="true"><img id="thumbPreviewImg" src="" alt="Preview"/></div>
    <button id="thumbToggle" title="Mostrar miniaturas" aria-label="Mostrar miniaturas">üñºÔ∏è</button>
    <button id="openVisorBtn" class="btn-primary" style="position:fixed; bottom:18px; right:18px; z-index:1300; padding:10px 12px; border-radius:8px; display:none;">üëÅÔ∏è Abrir Visor</button>

    <!-- Full-page viewer modal (flotante con header draggable) -->
    <div id="pageModal" class="modal" aria-hidden="true">
        <div class="modal-content floating-window" id="pageModalContent" role="dialog" aria-label="Visor de p√°gina">
            <div class="floating-header" id="pageModalHeader">
                <span id="floatingTitle">Visor de p√°gina</span>
                <div>
                    <button id="pinBtn" class="btn-secondary" onclick="togglePin(event)" title="Fijar/Desfijar">üìå</button>
                    <button class="btn-secondary" onclick="closePageModal()" title="Cerrar">‚úñ</button>
                </div>
            </div>
            <div style="padding:8px;">
                <img id="pageModalImg" src="" alt="P√°gina completa" style="max-width:100%; display:block; margin:0 auto;" />
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    <script>
        const pdfInput = document.getElementById('pdfInput');
        const btnStart = document.getElementById('btnStart');
        const btnClear = document.getElementById('btnClear');
        const statusDiv = document.getElementById('status');
        const resultDiv = document.getElementById('result');
        const tableContainer = document.getElementById('tableContainer');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const pageCounter = document.getElementById('pageCounter');
        let extractedData = [];
        let currentFile = null;
        // Almacenar canvases y resultados por p√°gina para re-procesos y diagn√≥stico
        let pagesCanvases = [];
        let pageResults = [];
        // Thumbnails and PDF ref
        let pageThumbs = [];
        let lastPdf = null;
        let pageModalPinned = false;
        // OpenCV status
        let opencvReady = false;
        function onOpenCvReady() {
            opencvReady = true;
            const s = document.getElementById('opencvStatus');
            if (s) { s.textContent = 'OpenCV cargado (preprocesado avanzado disponible)'; s.style.color = '#155724'; }
            console.log('‚úÖ OpenCV cargado');
        }
        function onOpenCvLoadError() {
            opencvReady = false;
            const s = document.getElementById('opencvStatus');
            if (s) { s.textContent = 'No se pudo cargar OpenCV. Usando preprocesado b√°sico'; s.style.color = '#856404'; }
            console.warn('‚ö†Ô∏è OpenCV no se pudo cargar');
        }

        pdfInput.addEventListener('change', () => {
            if(pdfInput.files.length > 0) {
                currentFile = pdfInput.files[0];
                enableStart();
                showStatus('‚úÖ Archivo PDF cargado. Listo para escanear.', 'status-ready');
            }
        });

        function enableStart() {
            btnStart.disabled = false;
            btnStart.classList.remove('btn-disabled');
        }

        function showStatus(message, statusClass) {
            statusDiv.style.display = 'block';
            statusDiv.textContent = message;
            statusDiv.className = statusClass;
        }

        async function startScan() {
            if(!currentFile) {
                alert('‚ö†Ô∏è Por favor selecciona un archivo PDF primero.');
                return;
            }
            btnStart.disabled = true;
            btnStart.classList.add('btn-disabled');
            showStatus('üîÑ Escaneando PDF... por favor espera.', 'status-processing');
            progressContainer.style.display = 'block';

            try {
                const arrayBuffer = await currentFile.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                const pdf = await pdfjsLib.getDocument({data: uint8Array.slice()}).promise;
                let rawText = '';

                for(let i=1; i<=pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    rawText += content.items.map(item => item.str).join(' ') + '\n';
                    
                    // Actualizar barra de progreso
                    updateProgress(i, pdf.numPages);
                }

                // Generar miniaturas del PDF para previsualizaci√≥n
                await generateThumbnails(pdf);

                // Detectar texto nativo para extraer directamente
                if(!textoTieneFormato(rawText)) {
                    showStatus('üì∏ PDF escaneado detectado. Iniciando OCR...', 'status-ocr');
                    console.log('‚ö†Ô∏è Activando OCR porque no se detect√≥ texto nativo');
                    extractedData = await ocrPDF(currentFile, pdf.numPages);
                    // Corregir confusiones comunes de OCR (B<->8, O<->0) en c√≥digos y descripciones
                    extractedData = applyOcrCorrectionsToProducts(extractedData);
                    // marcar progreso completo despu√©s de OCR
                    completeProgress();
                } else {
                    console.log('‚úÖ Extrayendo de texto nativo (no OCR)');
                    extractedData = extraerProductos(rawText);
                    // Corregir confusiones comunes de OCR (B<->8, O<->0)
                    extractedData = applyOcrCorrectionsToProducts(extractedData);
                    // marcar progreso completo despu√©s de extracci√≥n de texto
                    completeProgress();
                }

                if(extractedData.length === 0) {
                    showStatus('‚ö†Ô∏è No se encontraron productos. Verifica el PDF.', 'status-error');
                } else {
                    showStatus(`‚úÖ Escaneo completado. ${extractedData.length} productos extra√≠dos.`, 'status-ready');
                    displayTable();
                    btnClear.style.display = 'inline-block';
                }
                progressContainer.style.display = 'none';

            } catch(e) {
                console.error(e);
                showStatus('‚ùå Error procesando el PDF. Revisa el archivo y vuelve a intentarlo.', 'status-error');
                // Reset progress on error
                progressBar.style.width = '0%';
                progressText.textContent = '0%';
                pageCounter.textContent = '';
                progressContainer.style.display = 'none';
            }
            btnStart.disabled = false;
            btnStart.classList.remove('btn-disabled');
        }

        function updateProgress(current, total) {
            // Mostrar progreso parcial durante el procesamiento de p√°ginas.
            // Para evitar que la barra llegue a 100% antes de completar la extracci√≥n/OCR,
            // limitamos el progreso a 90% durante el loop de p√°ginas. El 100% se establece
            // expl√≠citamente cuando todo el procesamiento ha finalizado.
            const percentage = Math.round((current / total) * 90);
            progressBar.style.width = percentage + '%';
            progressText.textContent = percentage + '%';
            pageCounter.textContent = `P√°gina ${current}/${total}`;
        }

        function completeProgress() {
            progressBar.style.width = '100%';
            progressText.textContent = '100%';
        }

        function textoTieneFormato(texto) {
            // Detecta si el PDF tiene texto extra√≠ble de alta calidad
            if(!texto || texto.length < 50) return false;
            
            // Buscar patrones de producto/art√≠culo
            const tieneEncabezados = /producto|art√≠culo|descripci√≥n|cantidad|c√≥digo/i.test(texto);
            
            // Buscar al menos una l√≠nea con formato de producto (n√∫mero + texto)
            const lineas = texto.split('\n');
            const tieneProductos = lineas.some(linea => {
                // Buscar l√≠neas que empiezan con n√∫mero seguido de m√°s datos
                return /^\d+\s+\S+\s+.+/i.test(linea.trim());
            });
            
            // Considerar que tiene buen formato si:
            // - Tiene encabezados Y al menos 1 producto, O
            // - Tiene muchas l√≠neas con formato de producto
            const conteoProductos = lineas.filter(l => /^\d+\s+\S+/.test(l.trim())).length;
            
            return (tieneEncabezados && tieneProductos) || conteoProductos >= 3;
        }

        function extraerProductos(texto) {
            const lineas = texto.split('\n');
            const productos = [];
            const productosSet = new Set(); // Para evitar duplicados exactos
            
            console.log('üìù Texto completo para extracci√≥n:', texto.substring(0, 500));
            console.log('üìä Total de l√≠neas a procesar:', lineas.length);
            
            // Palabras clave para filtrar l√≠neas innecesarias
            const palabrasExcluidas = ['producto', 'cantidad', 'c√≥digo', 'descripci√≥n', 'c√≥digo', 'total', 'subtotal', 
                                      'iva', 'neto', 'p√°gina', 'factura', 'invoice', 'referencia', 'unitario', 'precio',
                                      'articulo', 'item', 'importe', 'unit', 'fecha', 'empresa', 'nombre', 'encabezado'];
            
            for(let i = 0; i < lineas.length; i++) {
                let linea = lineas[i].trim();
                
                // Saltar l√≠neas vac√≠as o muy cortas
                if(!linea || linea.length < 2) continue;
                
                // Saltar l√≠neas que son SOLO palabras clave
                const esEncabezado = palabrasExcluidas.some(palabra => 
                    linea.toUpperCase() === palabra.toUpperCase() || 
                    linea.toUpperCase().startsWith(palabra.toUpperCase() + ' ') ||
                    linea.toUpperCase().endsWith(' ' + palabra.toUpperCase())
                );
                if(esEncabezado) continue;
                
                let match = null;
                let cantidad = null;
                let codigo = null;
                let descripcion = null;
                
                // Patr√≥n 1: "n√∫mero  c√≥digo  descripci√≥n" (espacios m√∫ltiples)
                match = linea.match(/^(\d+)\s{2,}([A-Z0-9\-]{2,})\s{2,}(.{2,})$/i);
                if(match) {
                    cantidad = parseInt(match[1], 10);
                    codigo = match[2].trim();
                    descripcion = match[3].trim();
                }
                
                // Patr√≥n 2: "n√∫mero c√≥digo descripci√≥n" (espacios normales, c√≥digo alfanum√©rico)
                if(!match) {
                    match = linea.match(/^(\d+)\s+([A-Z0-9\-\.]+)\s+(.{2,})$/i);
                    if(match) {
                        cantidad = parseInt(match[1], 10);
                        codigo = match[2].trim();
                        descripcion = match[3].trim();
                    }
                }
                
                // Patr√≥n 3: "n√∫mero  palabra  palabra  palabra" (muy flexible, c√≥digo = primera palabra)
                if(!match) {
                    match = linea.match(/^(\d+)\s+(\S+)\s+(.{2,})$/i);
                    if(match) {
                        cantidad = parseInt(match[1], 10);
                        codigo = match[2].trim();
                        descripcion = match[3].trim();
                    }
                }
                
                // Patr√≥n 4: L√≠nea con n√∫mero inicial (al menos 3 caracteres m√°s)
                if(!match && /^\d+\s/.test(linea) && linea.length > 5) {
                    match = linea.match(/^(\d+)\s+(.+)$/);
                    if(match && match[2].length >= 3) {
                        cantidad = parseInt(match[1], 10);
                        const resto = match[2].trim();
                        const palabras = resto.split(/\s+/);
                        
                        if(palabras.length >= 2) {
                            codigo = palabras[0];
                            descripcion = palabras.slice(1).join(' ');
                        } else if(palabras.length === 1 && resto.length > 3) {
                            codigo = resto.substring(0, Math.min(10, resto.length));
                            descripcion = resto;
                        }
                    }
                }
                
                // Validaciones MENOS estrictas
                if(cantidad !== null && codigo && descripcion) {
                    // Validar cantidad
                    if(isNaN(cantidad) || cantidad < 1 || cantidad > 999999) continue;
                    
                    // Validar c√≥digo (muy flexible ahora)
                    codigo = codigo.trim();
                    if(codigo.length < 1) continue;
                    if(/^[\d\s\-\.]+$/.test(codigo) && codigo.length < 3) continue; // Solo n√∫meros y separadores
                    
                    // Validar descripci√≥n
                    descripcion = descripcion.trim();
                    if(descripcion.length < 2) continue;
                    if(/^[\d\-\._\s]+$/.test(descripcion)) continue; // Solo n√∫meros y s√≠mbolos
                    
                    // Crear clave √∫nica para evitar duplicados exactos
                    const clave = `${cantidad}|${codigo}|${descripcion}`.toLowerCase();
                    if(productosSet.has(clave)) continue;
                    
                    console.log(`‚úÖ Producto encontrado: ${cantidad} | ${codigo} | ${descripcion}`);
                    
                    productos.push({
                        cantidad: cantidad,
                        codigo: codigo,
                        descripcion: descripcion
                    });
                    
                    productosSet.add(clave);
                }
            }
            
            console.log(`üì¶ Total productos EXTRA√çDOS: ${productos.length}`);
            return productos;
        }

        async function ocrPDF(file, numPages) {
            // Cargar PDF
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            const pdf = await pdfjsLib.getDocument({data: uint8Array}).promise;

            pagesCanvases = [];
            pageResults = [];

            // Procesar p√°gina a p√°gina
            for(let i=1; i<=numPages; i++) {
                const page = await pdf.getPage(i);

                // Escalar para mejor OCR
                const viewport = page.getViewport({scale: 3.0});
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                await page.render({canvasContext: ctx, viewport}).promise;

                // Guardar canvas para re-procesos
                pagesCanvases[i-1] = canvas;

                // Procesar OCR por p√°gina (preprocesado + palabras TSV)
                const pageResult = await processPageOCR(canvas, i);
                pageResults[i-1] = pageResult;

                // Actualizar progreso y resumen por p√°gina
                updateProgress(i, numPages);
                displayPageSummaries(pageResults);
            }

            // Unir texto reconstruido de palabras por p√°gina para extracci√≥n global
            const allText = pageResults.map(pr => pr && pr.text ? pr.text : '').join('\n');

            console.log('üîç Texto OCR reconstruido (primeros 1000 caracteres):', allText.substring(0, 1000));

            // Extraer productos a partir del texto reconstruido
            const datos = extraerProductos(allText);

            // Adjuntar info de p√°gina a cada producto (opcional: podr√≠a mapearse mejor)
            console.log('üì¶ Productos extra√≠dos tras OCR por p√°gina:', datos.length);

            // Usar canvases generados para crear miniaturas (mejor calidad)
            renderThumbnailsFromCanvases();

            return datos;
        }

        // Preprocesado simple en canvas para mejorar OCR (si OpenCV no est√° disponible)
        function preprocessCanvas(canvas) {
            try {
                const enable = document.getElementById('enableAdvancedPreproc');
                if (enable && enable.checked && opencvReady && typeof cv !== 'undefined') {
                    // Usar OpenCV para preprocesado avanzado
                    preprocessCanvasWithOpenCV(canvas);
                    return;
                }
                // Fallback: preprocesado ligero en el canvas
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // Convertir a escala de grises y aumentar contraste
                const contrastFactor = 1.6; // 1.0=original
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2];
                    const gray = Math.round(0.299*r + 0.587*g + 0.114*b);
                    let v = Math.round((gray - 128) * contrastFactor + 128);
                    v = Math.max(0, Math.min(255, v));
                    // Umbral simple para resaltar texto
                    const out = v < 130 ? 0 : 255;
                    data[i] = data[i+1] = data[i+2] = out;
                }
                ctx.putImageData(imageData, 0, 0);
            } catch (e) {
                console.warn('‚ö†Ô∏è Preprocesado fall√≥, continuando sin √©l:', e);
            }
        }

        // Preprocesado avanzado usando OpenCV.js: deskew, CLAHE, adaptive threshold
        function preprocessCanvasWithOpenCV(canvas) {
            try {
                if(typeof cv === 'undefined') return;
                // Leer canvas en Mat
                let src = cv.imread(canvas);
                let gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

                // Aplicar CLAHE (mejora local de contraste)
                try {
                    let clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
                    clahe.apply(gray, gray);
                    clahe.delete();
                } catch(e) {
                    console.warn('‚ö†Ô∏è CLAHE no disponible o fall√≥:', e);
                }

                // Suavizado para reducir ruido
                cv.GaussianBlur(gray, gray, new cv.Size(3,3), 0, 0, cv.BORDER_DEFAULT);

                // Umbral adaptativo para binarizar
                let bin = new cv.Mat();
                cv.adaptiveThreshold(gray, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 15, 4);

                // Intentar deskew (rotaci√≥n) usando contornos grandes
                try {
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(bin, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
                    let maxArea = 0;
                    let maxCnt = null;
                    for (let i = 0; i < contours.size(); i++) {
                        let cnt = contours.get(i);
                        let area = cv.contourArea(cnt);
                        if (area > maxArea) { maxArea = area; maxCnt = cnt; }
                    }
                    if (maxCnt && maxArea > 1000) {
                        let rotatedRect = cv.minAreaRect(maxCnt);
                        let angle = rotatedRect.angle;
                        if (angle < -45) angle += 90;
                        if (Math.abs(angle) > 0.5) {
                            // Rotar la imagen binarizada
                            const center = new cv.Point(src.cols/2, src.rows/2);
                            const M = cv.getRotationMatrix2D(center, angle, 1);
                            let rotated = new cv.Mat();
                            cv.warpAffine(bin, rotated, M, new cv.Size(bin.cols, bin.rows), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));
                            bin.delete();
                            bin = rotated;
                            M.delete();
                        }
                        // liberar contorno grande
                        try { maxCnt.delete(); } catch(e) {}
                    }
                    contours.delete(); hierarchy.delete();
                } catch(e) {
                    console.warn('‚ö†Ô∏è Deskew fall√≥:', e);
                }

                // Mostrar resultado en el canvas (convertir a RGBA para el canvas)
                let out = new cv.Mat();
                cv.cvtColor(bin, out, cv.COLOR_GRAY2RGBA, 0);
                cv.imshow(canvas, out);

                // Liberar memoria
                src.delete(); gray.delete(); bin.delete(); out.delete();
            } catch (e) {
                console.warn('‚ö†Ô∏è Preprocesado OpenCV fall√≥, usando fallback:', e);
            }
        }

        // Convierte arreglo de palabras con bbox a texto ordenado por l√≠neas
        function wordsToText(words) {
            if(!words || words.length === 0) return '';

            // Agrupar en l√≠neas por coordenada Y (midpoint)
            const lines = [];
            const lineThreshold = Math.max(8, Math.min(20, Math.round(words[0] && words[0].bbox ? (words[0].bbox.y1 - words[0].bbox.y0) : 12)));

            words.forEach(w => {
                const bbox = w.bbox || {};
                const midY = ((bbox.y0 || 0) + (bbox.y1 || 0)) / 2;
                let placed = false;
                for (const line of lines) {
                    if (Math.abs(line.y - midY) <= lineThreshold) {
                        line.words.push(w);
                        placed = true;
                        break;
                    }
                }
                if (!placed) lines.push({ y: midY, words: [w] });
            });

            // Ordenar l√≠neas por Y y palabras dentro por X
            lines.sort((a,b) => a.y - b.y);
            const texto = lines.map(l => l.words.sort((a,b) => (a.bbox.x0 || 0) - (b.bbox.x0 || 0)).map(w => w.text).join(' ')).join('\n');
            return texto;
        }

        // Ejecuta OCR en un canvas y devuelve palabras, bbox y confianza promedio
        async function processPageOCR(canvas, pageNum) {
            // Duplicar canvas para no modificar el original
            const temp = document.createElement('canvas');
            temp.width = canvas.width;
            temp.height = canvas.height;
            const tctx = temp.getContext('2d');
            tctx.drawImage(canvas, 0, 0);

            // Preprocesado ligero
            preprocessCanvas(temp);

            showStatus(`üîé OCR p√°gina ${pageNum}...`, 'status-ocr');

            // Ejecutar Tesseract (con logger para progreso)
            const result = await Tesseract.recognize(temp, 'spa', {
                logger: m => {
                    if (m.status === 'recognizing text' && m.progress) {
                        // Mostrar avance del OCR dentro del texto de progreso
                        const pct = Math.round(m.progress * 100);
                        progressText.textContent = `OCR p${pageNum}: ${pct}%`;
                    }
                }
            });

            const rawWords = (result && result.data && result.data.words) ? result.data.words : [];
            const words = rawWords.map(w => ({
                text: (w.text || '').trim(),
                bbox: (w.bbox && typeof w.bbox === 'object') ? w.bbox : { x0:w.x0||0, y0:w.y0||0, x1:w.x1||0, y1:w.y1||0 },
                confidence: w.confidence || 0
            })).filter(w => w.text && w.text.length > 0);

            const avgConfidence = words.length ? Math.round(words.reduce((s,w)=>s+w.confidence,0)/words.length) : 0;
            const text = wordsToText(words);

            console.log(`üìÑ P√°gina ${pageNum} - palabras: ${words.length} - confianza media: ${avgConfidence}`);

            return { pageNum, words, avgConfidence, text };
        }

        // Mostrar resumen por p√°gina y botones para re-OCR
        function displayPageSummaries(results) {
            const container = document.getElementById('pageSummaries');
            if(!container) return;
            if(!results || results.length === 0) { container.innerHTML = ''; return; }

            const html = results.map((r, idx) => {
                if(!r) return '';
                const short = (r.text || '').substring(0, 150).replace(/\n/g,' ');
                return `<div style="padding:6px 8px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
                            <div><strong>P√°gina ${r.pageNum}</strong> ‚Äî Confianza: <strong>${r.avgConfidence}%</strong><br/><small style="color:#555;">${short}</small></div>
                            <div>
                                <button class="btn-secondary" onclick="reRunPageOCR(${idx})" title="Reintentar OCR de esta p√°gina">üîÅ Re-OCR</button>
                            </div>
                        </div>`;
            }).join('');

            container.innerHTML = html;
        }

        // Re-ejecutar OCR en una p√°gina espec√≠fica (usa canvas cacheado)
        async function reRunPageOCR(index) {
            if(!pagesCanvases[index]) { alert('Canvas de la p√°gina no disponible. Reprocesa todo el archivo.'); return; }
            showStatus('üîÑ Reintentando OCR en la p√°gina...', 'status-processing');
            const pageNum = index + 1;
            const newResult = await processPageOCR(pagesCanvases[index], pageNum);
            pageResults[index] = newResult;
            displayPageSummaries(pageResults);

            // Volver a extraer productos a partir del texto reconstruido
            const allText = pageResults.map(pr => pr && pr.text ? pr.text : '').join('\n');
            extractedData = extraerProductos(allText);
            // Corregir confusiones comunes de OCR (B<->8, O<->0)
            extractedData = applyOcrCorrectionsToProducts(extractedData);
            if(extractedData.length > 0) {
                displayTable();
                showStatus(`‚úÖ Extracci√≥n actualizada. ${extractedData.length} productos encontrados.`, 'status-ready');
            } else {
                showStatus('‚ö†Ô∏è No se encontraron productos tras re-OCR. Ajusta preprocesado o reintenta de nuevo.', 'status-error');
            }
        }

        // --- Thumbnails: generate, preview on hover, and open full page modal ---
        async function generateThumbnails(pdf) {
            try {
                lastPdf = pdf;
                const panel = document.getElementById('thumbnailPanel');
                panel.innerHTML = '';
                pageThumbs = [];

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 0.35 });
                    const canvas = document.createElement('canvas');
                    canvas.width = Math.round(viewport.width);
                    canvas.height = Math.round(viewport.height);
                    await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;

                    const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                    pageThumbs[i-1] = dataUrl;

                    const thumb = document.createElement('div');
                    thumb.className = 'thumb';
                    thumb.setAttribute('data-index', i-1);
                    thumb.innerHTML = `<img src="${dataUrl}" alt="P√°gina ${i}" /><div class="index">P ${i}</div>`;

                    // hover preview
                    thumb.addEventListener('mouseenter', (e) => showThumbPreview(i-1, e));
                    thumb.addEventListener('mouseleave', hideThumbPreview);
                    thumb.addEventListener('click', () => openPageModal(i-1));

                    panel.appendChild(thumb);
                }

                // Keep thumbnails hidden by default; show toggle for user control
                panel.style.display = 'none';
                try { const tt = document.getElementById('thumbToggle'); if(tt) tt.style.display = 'block'; } catch(e) {}
                const openBtn = document.getElementById('openVisorBtn'); if(openBtn) openBtn.style.display = 'inline-block';
            } catch (e) {
                console.warn('‚ö†Ô∏è No se pudieron generar miniaturas:', e);
            }
        }

        function renderThumbnailsFromCanvases() {
            const panel = document.getElementById('thumbnailPanel');
            if(!panel) return;
            panel.innerHTML = '';
            pageThumbs = [];
            for (let i = 0; i < pagesCanvases.length; i++) {
                const small = document.createElement('canvas');
                const c = pagesCanvases[i];
                const scale = Math.min(0.35, 160 / c.width);
                small.width = Math.round(c.width * scale);
                small.height = Math.round(c.height * scale);
                const ctx = small.getContext('2d');
                ctx.drawImage(c, 0, 0, small.width, small.height);
                const dataUrl = small.toDataURL('image/jpeg', 0.8);
                pageThumbs[i] = dataUrl;

                const thumb = document.createElement('div');
                thumb.className = 'thumb';
                thumb.setAttribute('data-index', i);
                thumb.innerHTML = `<img src="${dataUrl}" alt="P√°gina ${i+1}" /><div class="index">P ${i+1}</div>`;
                thumb.addEventListener('mouseenter', (e) => showThumbPreview(i, e));
                thumb.addEventListener('mouseleave', hideThumbPreview);
                thumb.addEventListener('click', () => openPageModal(i));
                panel.appendChild(thumb);
            }
            if(pagesCanvases.length > 0) { panel.style.display = 'none'; const openBtn = document.getElementById('openVisorBtn'); if(openBtn) openBtn.style.display = 'inline-block'; try { const tt = document.getElementById('thumbToggle'); if(tt) tt.style.display = 'block'; } catch(e) {} }
        }

        function showThumbPreview(index, event) {
            const preview = document.getElementById('thumbPreview');
            const img = document.getElementById('thumbPreviewImg');
            if(!preview || !img) return;
            img.src = pageThumbs[index] || '';
            preview.style.display = 'block';

            // Position near panel top (fixed); keep simple
            preview.style.top = Math.max(100, (event.clientY - 80)) + 'px';
        }

        function hideThumbPreview() {
            const preview = document.getElementById('thumbPreview');
            if(preview) preview.style.display = 'none';
        }

        // Allow pinning the window (so it doesn't close on outside click or ESC)
        function togglePin(e) {
            e.stopPropagation();
            pageModalPinned = !pageModalPinned;
            const modal = document.getElementById('pageModal');
            const btn = document.getElementById('pinBtn');
            if(pageModalPinned) {
                btn.style.opacity = '1';
                modal.classList.add('pinned');
            } else {
                btn.style.opacity = '0.8';
                modal.classList.remove('pinned');
            }
        }

        function makeModalDraggable(modalContent, header) {
            if(!modalContent || !header) return;
            header.style.cursor = 'move';
            let isDown = false;
            let startX=0, startY=0, origX=0, origY=0;
            header.onmousedown = function(e) {
                isDown = true;
                startX = e.clientX;
                startY = e.clientY;
                const rect = modalContent.getBoundingClientRect();
                origX = rect.left;
                origY = rect.top;
                document.body.style.userSelect = 'none';
            };
            document.onmousemove = function(e) {
                if(!isDown) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                modalContent.style.left = (origX + dx) + 'px';
                modalContent.style.top = (origY + dy) + 'px';
                modalContent.style.transform = 'none';
            };
            document.onmouseup = function() {
                if(isDown) {
                    isDown = false;
                    document.body.style.userSelect = '';
                }
            };

            // Touch support (basic)
            header.ontouchstart = function(ev) {
                const e = ev.touches[0];
                isDown = true; startX = e.clientX; startY = e.clientY; const rect = modalContent.getBoundingClientRect(); origX = rect.left; origY = rect.top;
            };
            header.ontouchmove = function(ev) {
                if(!isDown) return; const e = ev.touches[0]; const dx = e.clientX - startX; const dy = e.clientY - startY; modalContent.style.left = (origX + dx) + 'px'; modalContent.style.top = (origY + dy) + 'px'; modalContent.style.transform = 'none';
            };
            header.ontouchend = function() { isDown = false; };
        }

        async function openPageModal(index) {
            const modal = document.getElementById('pageModal');
            const img = document.getElementById('pageModalImg');
            const modalContent = document.getElementById('pageModalContent');
            const header = document.getElementById('pageModalHeader');
            if(!modal || !img || !modalContent) return;

            // If we have a high-res canvas cached, use it
            if (pagesCanvases[index]) {
                img.src = pagesCanvases[index].toDataURL('image/png');
                modal.style.display = 'flex';
                modal.setAttribute('aria-hidden', 'false');
                // set initial center position if blank
                if(!modalContent.style.left) { modalContent.style.left = '50%'; modalContent.style.top = '10vh'; modalContent.style.transform = 'translateX(-50%)'; }
                makeModalDraggable(modalContent, header);
                // ESC to close if not pinned
                document.onkeydown = function(e) { if(e.key === 'Escape' && !pageModalPinned) closePageModal(); };
                modal.onclick = function(e) { if(e.target === modal && !pageModalPinned) closePageModal(); };
                return;
            }

            // Otherwise render from lastPdf at larger scale
            if (lastPdf) {
                try {
                    const page = await lastPdf.getPage(index+1);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    canvas.width = Math.round(viewport.width);
                    canvas.height = Math.round(viewport.height);
                    await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                    img.src = canvas.toDataURL('image/png');
                    modal.style.display = 'flex';
                    modal.setAttribute('aria-hidden', 'false');
                    if(!modalContent.style.left) { modalContent.style.left = '50%'; modalContent.style.top = '10vh'; modalContent.style.transform = 'translateX(-50%)'; }
                    makeModalDraggable(modalContent, header);
                    document.onkeydown = function(e) { if(e.key === 'Escape' && !pageModalPinned) closePageModal(); };
                    modal.onclick = function(e) { if(e.target === modal && !pageModalPinned) closePageModal(); };
                } catch(e) {
                    console.warn('No se pudo renderizar la p√°gina en grande:', e);
                }
            }
        }

        function closePageModal() {
            const modal = document.getElementById('pageModal');
            const img = document.getElementById('pageModalImg');
            const modalContent = document.getElementById('pageModalContent');
            if(modal) { modal.style.display = 'none'; modal.setAttribute('aria-hidden', 'true'); }
            if(img) img.src = '';
            // reset handlers
            document.onkeydown = null;
            if(modal) modal.onclick = null;
            // optional: don't reset modalContent position so user keeps placement
        }

        function displayTable() {
            if(extractedData.length === 0) {
                console.warn('‚ö†Ô∏è No hay datos para mostrar. extractedData:', extractedData);
                return;
            }
            
            resultDiv.style.display = 'block';
            let totalCantidad = extractedData.reduce((acc, val) => acc + (val.cantidad || 0), 0);

            // helper to escape HTML in values
            function escapeHtml(str) {
                if(str === null || str === undefined) return '';
                return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
            }

            let html = `<h3>üìã ${extractedData.length} productos encontrados | Total unidades: ${totalCantidad}</h3>
                        <table>
                            <thead>
                                <tr><th>CANTIDAD</th><th>C√ìDIGO</th><th>DESCRIPCI√ìN</th></tr>
                            </thead>
                            <tbody>
                            ${extractedData.map((d, idx) => `
                                <tr data-idx="${idx}">
                                    <td><input type="number" min="0" class="cell-qty" value="${d.cantidad || 0}" /></td>
                                    <td><input type="text" class="cell-code" value="${escapeHtml(d.codigo || '')}" /></td>
                                    <td><input type="text" class="cell-desc" value="${escapeHtml(d.descripcion || '')}" /></td>
                                </tr>
                            `).join('')}
                            </tbody>
                        </table>`;
            
            tableContainer.innerHTML = html;

            // Attach listeners to inputs to keep extractedData in sync
            const rows = tableContainer.querySelectorAll('tbody tr');
            rows.forEach(tr => {
                const idx = parseInt(tr.getAttribute('data-idx'), 10);
                const qty = tr.querySelector('.cell-qty');
                const code = tr.querySelector('.cell-code');
                const desc = tr.querySelector('.cell-desc');

                const onInput = () => {
                    const qv = parseInt(qty.value, 10);
                    extractedData[idx].cantidad = isNaN(qv) ? 0 : qv;
                    extractedData[idx].codigo = code.value.trim();
                    extractedData[idx].descripcion = desc.value.trim();

                    // mark edited visually
                    tr.classList.add('edited');

                    // update total display
                    const newTotal = extractedData.reduce((acc, val) => acc + (val.cantidad || 0), 0);
                    const h3 = tableContainer.querySelector('h3');
                    if(h3) h3.textContent = `üìã ${extractedData.length} productos encontrados | Total unidades: ${newTotal}`;

                    validateTable();
                };

                qty.addEventListener('input', onInput);
                code.addEventListener('input', onInput);
                desc.addEventListener('input', onInput);
            });

            // Initial validation
            validateTable();
        }

        // Validar la tabla: cantidad > 0 y c√≥digo no vac√≠o. Deshabilita bot√≥n de Enviar si hay errores.
        function validateTable() {
            const btnSend = document.getElementById('btnSendSheet');
            if(!btnSend) return;
            let invalid = false;
            const rows = tableContainer.querySelectorAll('tbody tr');
            rows.forEach(tr => {
                const qty = tr.querySelector('.cell-qty');
                const code = tr.querySelector('.cell-code');
                // reset styles
                qty.style.borderColor = '';
                code.style.borderColor = '';

                const qv = parseInt(qty.value, 10);
                if(isNaN(qv) || qv <= 0) {
                    qty.style.borderColor = '#dc3545';
                    invalid = true;
                }
                if(!code.value || code.value.trim().length === 0) {
                    code.style.borderColor = '#dc3545';
                    invalid = true;
                }
            });
            btnSend.disabled = invalid;
            if(invalid) {
                btnSend.classList.add('btn-disabled');
                showStatus('‚ö†Ô∏è Corrige valores inv√°lidos antes de enviar (cantidad > 0 y c√≥digo no vac√≠o).', 'status-error');
            } else {
                btnSend.classList.remove('btn-disabled');
                showStatus(`‚úÖ Listo para enviar. ${extractedData.length} productos.`, 'status-ready');
            }
        }

        function downloadCSV() {
            if(extractedData.length === 0) return;
            const csv = ['Cantidad,Codigo,Descripcion', ...extractedData.map(d =>
                `${d.cantidad},"${d.codigo}","${d.descripcion.replace(/"/g,'""')}"`
            )].join('\n');

            const blob = new Blob([csv], {type:'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `llantas_${new Date().toISOString().slice(0,10)}.csv`;
            a.click();
        }

        function copyTable() {
            if(extractedData.length === 0) return;
            const text = extractedData.map(d => `${d.cantidad}\t${d.codigo}\t${d.descripcion}`).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                alert('¬°Tabla copiada al portapapeles!');
            });
        }

        // Modal control: abrir/cerrar
        function openNameModal() {
            const modal = document.getElementById('nameModal');
            const input = document.getElementById('sheetNameInput');
            let defaultName = '';
            if (currentFile && currentFile.name) {
                // Quitar extensi√≥n del archivo
                defaultName = currentFile.name.replace(/\.[^/.]+$/, '');
                // Eliminar caracteres no v√°lidos para nombres (/, \\, :, *, ?, ", <, >, |)
                defaultName = defaultName.replace(/[\/\\:\*\?"<>|]/g, '').trim();
            }
            input.value = defaultName || 'Traspasos';
            modal.style.display = 'flex';
            // Seleccionar todo para que el usuario pueda editar r√°pidamente
            setTimeout(() => { input.focus(); input.select(); }, 50);
        }

        function closeNameModal() {
            const modal = document.getElementById('nameModal');
            modal.style.display = 'none';
        }

        // Sanitizar texto antes de enviarlo a la base de datos
        // Permite: letras (incluye acentos), n√∫meros, espacios, par√©ntesis, gui√≥n, gui√≥n bajo, barra y punto
        // Incluye regla especial: corregir HUO1 ‚Üí HU01 en descripciones
        function sanitizeTextForDB(value) {
            if(value === null || value === undefined) return '';
            let cleaned = '';
            try {
                cleaned = String(value).replace(/[^\p{L}\p{N}\s()\-_/\.]/gu, '').trim();
            } catch (e) {
                // Si el entorno no soporta \p{L}/unicode, usar alternativa conservadora (letras latinas b√°sicas + n√∫meros)
                cleaned = String(value).replace(/[^A-Za-z0-9\s()\-_/\.]/g, '').trim();
            }
            // Regla especial: corregir HUO1 ‚Üí HU01 (letra + letra + letra + n√∫mero ‚Üí letra + letra + n√∫mero + letra)
            cleaned = cleaned.replace(/HUO(\d)/g, 'HU0$1');
            return cleaned;
        }

        // --- Correcciones post-OCR para reducir confusiones comunes (B<->8, O<->0) ---
        function fixOcrConfusionsInToken(token) {
            if(!token) return token;
            let t = String(token).trim();
            if(!t) return t;
            const orig = t;
            // contar letras y d√≠gitos
            const letters = (t.match(/[A-Za-z√Å√â√ç√ì√ö√ë√°√©√≠√≥√∫√±]/g) || []).length;
            const digits = (t.match(/[0-9]/g) || []).length;

            // Contextual replacements:
            // Si hay m√°s d√≠gitos que letras: preferir n√∫meros (O->0, B->8)
            if(digits > letters) {
                // O junto a d√≠gitos -> 0
                t = t.replace(/([0-9])O/g, '$10').replace(/O([0-9])/g, '0$1');
                t = t.replace(/O/g, '0');
                // B junto a d√≠gitos -> 8
                t = t.replace(/([0-9])B/g, '$18').replace(/B([0-9])/g, '8$1');
                t = t.replace(/B/g, '8');
            } else if(letters > digits) {
                // 0 junto a letras -> O
                t = t.replace(/([A-Za-z])0/g, '$1O').replace(/0([A-Za-z])/g, 'O$1');
                t = t.replace(/0/g, 'O');
                // 8 junto a letras -> B
                t = t.replace(/([A-Za-z])8/g, '$1B').replace(/8([A-Za-z])/g, 'B$1');
                t = t.replace(/8/g, 'B');
            } else {
                // Mixto o igual: usar contexto (adyacencia)
                t = t.replace(/([0-9])O/g, '$10').replace(/O([0-9])/g, '0$1');
                t = t.replace(/([A-Za-z])0/g, '$1O').replace(/0([A-Za-z])/g, 'O$1');
                t = t.replace(/([0-9])B/g, '$18').replace(/B([0-9])/g, '8$1');
                t = t.replace(/([A-Za-z])8/g, '$1B').replace(/8([A-Za-z])/g, 'B$1');
            }

            // √öltimo paso: normalizar a may√∫sculas para c√≥digos cortos
            if(t.length <= 20) t = t.toUpperCase();

            if(t !== orig) console.log(`üîß OCR fix: "${orig}" ‚Üí "${t}"`);
            return t;
        }

        function applyOcrCorrectionsToProducts(products) {
            if(!Array.isArray(products)) return products;
            products.forEach(p => {
                if(p && p.codigo) p.codigo = fixOcrConfusionsInToken(p.codigo);
                if(p && p.descripcion) {
                    // Correcciones m√°s suaves en descripci√≥n: 0‚ÜíO y 8‚ÜíB cuando est√°n dentro de palabras (letras alrededor)
                    p.descripcion = String(p.descripcion)
                        .replace(/([A-Za-z])0([A-Za-z])/g, '$1O$2')
                        .replace(/([A-Za-z])8([A-Za-z])/g, '$1B$2');
                }
            });
            return products;
        }

        // Confirmar y enviar a SheetDB
        async function confirmSendToSheetDB() {
            const input = document.getElementById('sheetNameInput');
            const rawNombre = (input.value || '').trim();
            const nombre = sanitizeTextForDB(rawNombre);
            if(!nombre) {
                alert('Por favor ingresa un nombre v√°lido (solo letras, n√∫meros y - _ / . ()).');
                input.focus();
                return;
            }
            closeNameModal();
            await sendToSheetDB(nombre);
        }

        async function sendToSheetDB(nombre) {
            if(!extractedData || extractedData.length === 0) {
                alert('No hay datos para enviar.');
                return;
            }

            // Construir filas: rellenar solo lo que tenemos, dem√°s como cadena vac√≠a
            // A√±adimos tanto 'traspasos/Nombre' como 'Nombre' por compatibilidad
            const safeNombre = sanitizeTextForDB(nombre);
            const rows = extractedData.map(item => ({
                'traspasos/Nombre': safeNombre,
                'Nombre': safeNombre,
                'Folio': '',
                'Fecha de Emisi√≥n': '',
                'Usuario': '',
                'Cantidad': item.cantidad != null ? String(item.cantidad) : '',
                'C√≥digo': sanitizeTextForDB(item.codigo || ''),
                'Descripci√≥n': sanitizeTextForDB(item.descripcion || '')
            }));

            try {
                showStatus('üîÑ Enviando datos a la hoja...','status-processing');

                // Enviar expl√≠citamente a la hoja llamada "traspasos"
                const res = await fetch('https://sheetdb.io/api/v1/he6n1zuoqus5b?sheet=traspasos', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: rows })
                });

                if(!res.ok) {
                    const errText = await res.text();
                    console.error('SheetDB error:', res.status, errText);
                    showStatus('‚ùå Error al enviar: ' + res.status, 'status-error');
                    alert('Error al enviar los datos. Revisa la consola para m√°s detalles.');
                    return;
                }

                const json = await res.json();
                console.log('SheetDB response', json);
                showStatus('‚úÖ Datos enviados correctamente a la hoja "traspasos".', 'status-ready');
                alert('Datos enviados correctamente a la hoja "traspasos".');

                // Limpiar datos extra√≠dos y la interfaz tal como solicitaste
                extractedData = [];
                resultDiv.style.display = 'none';
                tableContainer.innerHTML = '';
                btnClear.style.display = 'none';
                pdfInput.value = '';
                // Deshabilitar bot√≥n de inicio hasta que se cargue otro PDF
                btnStart.disabled = true;
                if(!btnStart.classList.contains('btn-disabled')) btnStart.classList.add('btn-disabled');
                // Reset progreso visual
                progressBar.style.width = '0%';
                progressText.textContent = '0%';
                pageCounter.textContent = '';
                showStatus('Esperando archivo PDF...', 'status-ready');
            } catch (e) {
                console.error('Error al enviar a SheetDB', e);
                showStatus('‚ùå Error al enviar los datos.', 'status-error');
                alert('Ocurri√≥ un error al enviar los datos. Revisa la consola.');
            }
        }

        function confirmClearCache() {
            if (confirm('¬øDeseas borrar la cach√© y recargar la p√°gina?')) {
                clearCache();
            }
        }

        function confirmClearCache() {
            if (confirm('¬øDeseas borrar la cach√© y recargar la p√°gina?')) {
                clearCache();
            }
        }

        function clearCache() {
            try {
                // Limpiar localStorage y sessionStorage
                if (window.localStorage) localStorage.clear();
                if (window.sessionStorage) sessionStorage.clear();
            } catch (e) {
                console.warn('No se pudo limpiar storage:', e);
            }

            if ('caches' in window) {
                caches.keys().then(keys => Promise.all(keys.map(k => caches.delete(k))))
                    .then(() => {
                        showStatus('‚úÖ Cach√© y almacenamiento limpiados.', 'status-ready');
                        // Recargar para aplicar cambios
                        setTimeout(() => location.reload(), 600);
                    }).catch(err => {
                        console.error('Error limpiando Cache Storage:', err);
                        showStatus('‚ö†Ô∏è Error al limpiar la cach√©.', 'status-error');
                        alert('Ocurri√≥ un error al limpiar la cach√©. Revisa la consola.');
                    });
            } else {
                showStatus('‚úÖ Almacenamiento local limpiado.', 'status-ready');
                setTimeout(() => location.reload(), 600);
            }
        }

        function clearAll() {
            extractedData = [];
            pdfInput.value = '';
            resultDiv.style.display = 'none';
            tableContainer.innerHTML = '';
            btnClear.style.display = 'none';

            // Limpiar miniaturas y canvases
            try { document.getElementById('thumbnailPanel').innerHTML = ''; document.getElementById('thumbnailPanel').style.display = 'none'; } catch(e) {}
            // Ocultar bot√≥n Abrir Visor y reset pin
            try { const ob = document.getElementById('openVisorBtn'); if(ob) ob.style.display = 'none'; } catch(e) {}
            try { const tt = document.getElementById('thumbToggle'); if(tt) tt.style.display = 'none'; tt.classList.remove('active'); } catch(e) {}
            pageModalPinned = false;
            pageThumbs = [];
            pagesCanvases = [];
            lastPdf = null;

            btnStart.disabled = true;
            btnStart.classList.add('btn-disabled');
            showStatus('Esperando archivo PDF...', 'status-ready');
        }

        // Cerrar modal con clic fuera o ESC (respeta pin)
        (function(){
            const pageModalEl = document.getElementById('pageModal');
            if (pageModalEl) {
                pageModalEl.addEventListener('click', (e)=>{ if (e.target === pageModalEl && !pageModalPinned) closePageModal(); });
            }
            window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && !pageModalPinned) closePageModal(); });
        })();

        // Abrir visor con bot√≥n flotante
        (function(){
            const openVisorBtn = document.getElementById('openVisorBtn');
            if(openVisorBtn) {
                openVisorBtn.addEventListener('click', ()=> {
                    if(pageThumbs && pageThumbs.length > 0) openPageModal(0);
                    else alert('No hay p√°ginas disponibles para mostrar.');
                });
            }

            // Toggle thumbnails with a single click
            function toggleThumbnailPanel() {
                const panel = document.getElementById('thumbnailPanel');
                const toggle = document.getElementById('thumbToggle');
                if(!panel || !toggle) return;
                if(panel.style.display === 'block') {
                    panel.style.display = 'none';
                    panel.setAttribute('aria-hidden', 'true');
                    toggle.classList.remove('active');
                    toggle.title = 'Mostrar miniaturas';
                } else {
                    panel.style.display = 'block';
                    panel.setAttribute('aria-hidden', 'false');
                    toggle.classList.add('active');
                    toggle.title = 'Ocultar miniaturas';
                }
            }

            const thumbToggle = document.getElementById('thumbToggle');
            if(thumbToggle) {
                thumbToggle.addEventListener('click', (e)=>{
                    e.stopPropagation();
                    toggleThumbnailPanel();
                });
            }
        })();
    </script>
</body>

</html>